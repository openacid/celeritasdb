// This file is generated by rust-protobuf 2.10.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `message.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_10_1;

#[derive(PartialEq,Clone,Default)]
pub struct Message {
    // message fields
    pub req_type: RequestType,
    pub msg_type: MessageType,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // .RequestType req_type = 2;


    pub fn get_req_type(&self) -> RequestType {
        self.req_type
    }
    pub fn clear_req_type(&mut self) {
        self.req_type = RequestType::Prepare;
    }

    // Param is passed by value, moved
    pub fn set_req_type(&mut self, v: RequestType) {
        self.req_type = v;
    }

    // .MessageType msg_type = 3;


    pub fn get_msg_type(&self) -> MessageType {
        self.msg_type
    }
    pub fn clear_msg_type(&mut self) {
        self.msg_type = MessageType::TypeRequest;
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: MessageType) {
        self.msg_type = v;
    }

    // bytes data = 4;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Message {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.req_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.msg_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.req_type != RequestType::Prepare {
            my_size += ::protobuf::rt::enum_size(2, self.req_type);
        }
        if self.msg_type != MessageType::TypeRequest {
            my_size += ::protobuf::rt::enum_size(3, self.msg_type);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.req_type != RequestType::Prepare {
            os.write_enum(2, self.req_type.value())?;
        }
        if self.msg_type != MessageType::TypeRequest {
            os.write_enum(3, self.msg_type.value())?;
        }
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Message {
        Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RequestType>>(
                    "req_type",
                    |m: &Message| { &m.req_type },
                    |m: &mut Message| { &mut m.req_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MessageType>>(
                    "msg_type",
                    |m: &Message| { &m.msg_type },
                    |m: &mut Message| { &mut m.msg_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Message| { &m.data },
                    |m: &mut Message| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Message>(
                    "Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Message {
        static mut instance: ::protobuf::lazy::Lazy<Message> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Message,
        };
        unsafe {
            instance.get(Message::new)
        }
    }
}

impl ::protobuf::Clear for Message {
    fn clear(&mut self) {
        self.req_type = RequestType::Prepare;
        self.msg_type = MessageType::TypeRequest;
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request {
    // message fields
    pub req_type: RequestType,
    pub to_replica_id: i64,
    pub ballot: ::protobuf::SingularPtrField<super::instance::BallotNum>,
    pub instance_id: ::protobuf::SingularPtrField<super::instance::InstanceID>,
    pub cmds: ::protobuf::RepeatedField<super::command::Command>,
    pub initial_deps: ::protobuf::RepeatedField<super::instance::InstanceID>,
    pub deps_committed: ::std::vec::Vec<bool>,
    pub final_deps: ::protobuf::RepeatedField<super::instance::InstanceID>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request {
    fn default() -> &'a Request {
        <Request as ::protobuf::Message>::default_instance()
    }
}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    // .RequestType req_type = 1;


    pub fn get_req_type(&self) -> RequestType {
        self.req_type
    }
    pub fn clear_req_type(&mut self) {
        self.req_type = RequestType::Prepare;
    }

    // Param is passed by value, moved
    pub fn set_req_type(&mut self, v: RequestType) {
        self.req_type = v;
    }

    // int64 to_replica_id = 2;


    pub fn get_to_replica_id(&self) -> i64 {
        self.to_replica_id
    }
    pub fn clear_to_replica_id(&mut self) {
        self.to_replica_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_to_replica_id(&mut self, v: i64) {
        self.to_replica_id = v;
    }

    // .BallotNum ballot = 12;


    pub fn get_ballot(&self) -> &super::instance::BallotNum {
        self.ballot.as_ref().unwrap_or_else(|| super::instance::BallotNum::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: super::instance::BallotNum) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut super::instance::BallotNum {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> super::instance::BallotNum {
        self.ballot.take().unwrap_or_else(|| super::instance::BallotNum::new())
    }

    // .InstanceID instance_id = 13;


    pub fn get_instance_id(&self) -> &super::instance::InstanceID {
        self.instance_id.as_ref().unwrap_or_else(|| super::instance::InstanceID::default_instance())
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id.clear();
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: super::instance::InstanceID) {
        self.instance_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_id(&mut self) -> &mut super::instance::InstanceID {
        if self.instance_id.is_none() {
            self.instance_id.set_default();
        }
        self.instance_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_id(&mut self) -> super::instance::InstanceID {
        self.instance_id.take().unwrap_or_else(|| super::instance::InstanceID::new())
    }

    // repeated .Command cmds = 21;


    pub fn get_cmds(&self) -> &[super::command::Command] {
        &self.cmds
    }
    pub fn clear_cmds(&mut self) {
        self.cmds.clear();
    }

    // Param is passed by value, moved
    pub fn set_cmds(&mut self, v: ::protobuf::RepeatedField<super::command::Command>) {
        self.cmds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cmds(&mut self) -> &mut ::protobuf::RepeatedField<super::command::Command> {
        &mut self.cmds
    }

    // Take field
    pub fn take_cmds(&mut self) -> ::protobuf::RepeatedField<super::command::Command> {
        ::std::mem::replace(&mut self.cmds, ::protobuf::RepeatedField::new())
    }

    // repeated .InstanceID initial_deps = 31;


    pub fn get_initial_deps(&self) -> &[super::instance::InstanceID] {
        &self.initial_deps
    }
    pub fn clear_initial_deps(&mut self) {
        self.initial_deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_initial_deps(&mut self, v: ::protobuf::RepeatedField<super::instance::InstanceID>) {
        self.initial_deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_initial_deps(&mut self) -> &mut ::protobuf::RepeatedField<super::instance::InstanceID> {
        &mut self.initial_deps
    }

    // Take field
    pub fn take_initial_deps(&mut self) -> ::protobuf::RepeatedField<super::instance::InstanceID> {
        ::std::mem::replace(&mut self.initial_deps, ::protobuf::RepeatedField::new())
    }

    // repeated bool deps_committed = 33;


    pub fn get_deps_committed(&self) -> &[bool] {
        &self.deps_committed
    }
    pub fn clear_deps_committed(&mut self) {
        self.deps_committed.clear();
    }

    // Param is passed by value, moved
    pub fn set_deps_committed(&mut self, v: ::std::vec::Vec<bool>) {
        self.deps_committed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deps_committed(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.deps_committed
    }

    // Take field
    pub fn take_deps_committed(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.deps_committed, ::std::vec::Vec::new())
    }

    // repeated .InstanceID final_deps = 41;


    pub fn get_final_deps(&self) -> &[super::instance::InstanceID] {
        &self.final_deps
    }
    pub fn clear_final_deps(&mut self) {
        self.final_deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_final_deps(&mut self, v: ::protobuf::RepeatedField<super::instance::InstanceID>) {
        self.final_deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_final_deps(&mut self) -> &mut ::protobuf::RepeatedField<super::instance::InstanceID> {
        &mut self.final_deps
    }

    // Take field
    pub fn take_final_deps(&mut self) -> ::protobuf::RepeatedField<super::instance::InstanceID> {
        ::std::mem::replace(&mut self.final_deps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Request {
    fn is_initialized(&self) -> bool {
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instance_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cmds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initial_deps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.final_deps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.req_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.to_replica_id = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_id)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cmds)?;
                },
                31 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.initial_deps)?;
                },
                33 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.deps_committed)?;
                },
                41 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.final_deps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.req_type != RequestType::Prepare {
            my_size += ::protobuf::rt::enum_size(1, self.req_type);
        }
        if self.to_replica_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.to_replica_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.cmds {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.initial_deps {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += 3 * self.deps_committed.len() as u32;
        for value in &self.final_deps {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.req_type != RequestType::Prepare {
            os.write_enum(1, self.req_type.value())?;
        }
        if self.to_replica_id != 0 {
            os.write_int64(2, self.to_replica_id)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.cmds {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.initial_deps {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.deps_committed {
            os.write_bool(33, *v)?;
        };
        for v in &self.final_deps {
            os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request {
        Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RequestType>>(
                    "req_type",
                    |m: &Request| { &m.req_type },
                    |m: &mut Request| { &mut m.req_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "to_replica_id",
                    |m: &Request| { &m.to_replica_id },
                    |m: &mut Request| { &mut m.to_replica_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::BallotNum>>(
                    "ballot",
                    |m: &Request| { &m.ballot },
                    |m: &mut Request| { &mut m.ballot },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "instance_id",
                    |m: &Request| { &m.instance_id },
                    |m: &mut Request| { &mut m.instance_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::command::Command>>(
                    "cmds",
                    |m: &Request| { &m.cmds },
                    |m: &mut Request| { &mut m.cmds },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "initial_deps",
                    |m: &Request| { &m.initial_deps },
                    |m: &mut Request| { &mut m.initial_deps },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "deps_committed",
                    |m: &Request| { &m.deps_committed },
                    |m: &mut Request| { &mut m.deps_committed },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "final_deps",
                    |m: &Request| { &m.final_deps },
                    |m: &mut Request| { &mut m.final_deps },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Request>(
                    "Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Request {
        static mut instance: ::protobuf::lazy::Lazy<Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Request,
        };
        unsafe {
            instance.get(Request::new)
        }
    }
}

impl ::protobuf::Clear for Request {
    fn clear(&mut self) {
        self.req_type = RequestType::Prepare;
        self.to_replica_id = 0;
        self.ballot.clear();
        self.instance_id.clear();
        self.cmds.clear();
        self.initial_deps.clear();
        self.deps_committed.clear();
        self.final_deps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Reply {
    // message fields
    pub req_type: RequestType,
    pub last_ballot: ::protobuf::SingularPtrField<super::instance::BallotNum>,
    pub instance_id: ::protobuf::SingularPtrField<super::instance::InstanceID>,
    pub deps: ::protobuf::RepeatedField<super::instance::InstanceID>,
    pub deps_committed: ::std::vec::Vec<bool>,
    pub final_deps: ::protobuf::RepeatedField<super::instance::InstanceID>,
    pub committed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Reply {
    fn default() -> &'a Reply {
        <Reply as ::protobuf::Message>::default_instance()
    }
}

impl Reply {
    pub fn new() -> Reply {
        ::std::default::Default::default()
    }

    // .RequestType req_type = 1;


    pub fn get_req_type(&self) -> RequestType {
        self.req_type
    }
    pub fn clear_req_type(&mut self) {
        self.req_type = RequestType::Prepare;
    }

    // Param is passed by value, moved
    pub fn set_req_type(&mut self, v: RequestType) {
        self.req_type = v;
    }

    // .BallotNum last_ballot = 11;


    pub fn get_last_ballot(&self) -> &super::instance::BallotNum {
        self.last_ballot.as_ref().unwrap_or_else(|| super::instance::BallotNum::default_instance())
    }
    pub fn clear_last_ballot(&mut self) {
        self.last_ballot.clear();
    }

    pub fn has_last_ballot(&self) -> bool {
        self.last_ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ballot(&mut self, v: super::instance::BallotNum) {
        self.last_ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_ballot(&mut self) -> &mut super::instance::BallotNum {
        if self.last_ballot.is_none() {
            self.last_ballot.set_default();
        }
        self.last_ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_ballot(&mut self) -> super::instance::BallotNum {
        self.last_ballot.take().unwrap_or_else(|| super::instance::BallotNum::new())
    }

    // .InstanceID instance_id = 13;


    pub fn get_instance_id(&self) -> &super::instance::InstanceID {
        self.instance_id.as_ref().unwrap_or_else(|| super::instance::InstanceID::default_instance())
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id.clear();
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: super::instance::InstanceID) {
        self.instance_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_id(&mut self) -> &mut super::instance::InstanceID {
        if self.instance_id.is_none() {
            self.instance_id.set_default();
        }
        self.instance_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_id(&mut self) -> super::instance::InstanceID {
        self.instance_id.take().unwrap_or_else(|| super::instance::InstanceID::new())
    }

    // repeated .InstanceID deps = 32;


    pub fn get_deps(&self) -> &[super::instance::InstanceID] {
        &self.deps
    }
    pub fn clear_deps(&mut self) {
        self.deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_deps(&mut self, v: ::protobuf::RepeatedField<super::instance::InstanceID>) {
        self.deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deps(&mut self) -> &mut ::protobuf::RepeatedField<super::instance::InstanceID> {
        &mut self.deps
    }

    // Take field
    pub fn take_deps(&mut self) -> ::protobuf::RepeatedField<super::instance::InstanceID> {
        ::std::mem::replace(&mut self.deps, ::protobuf::RepeatedField::new())
    }

    // repeated bool deps_committed = 33;


    pub fn get_deps_committed(&self) -> &[bool] {
        &self.deps_committed
    }
    pub fn clear_deps_committed(&mut self) {
        self.deps_committed.clear();
    }

    // Param is passed by value, moved
    pub fn set_deps_committed(&mut self, v: ::std::vec::Vec<bool>) {
        self.deps_committed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deps_committed(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.deps_committed
    }

    // Take field
    pub fn take_deps_committed(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.deps_committed, ::std::vec::Vec::new())
    }

    // repeated .InstanceID final_deps = 41;


    pub fn get_final_deps(&self) -> &[super::instance::InstanceID] {
        &self.final_deps
    }
    pub fn clear_final_deps(&mut self) {
        self.final_deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_final_deps(&mut self, v: ::protobuf::RepeatedField<super::instance::InstanceID>) {
        self.final_deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_final_deps(&mut self) -> &mut ::protobuf::RepeatedField<super::instance::InstanceID> {
        &mut self.final_deps
    }

    // Take field
    pub fn take_final_deps(&mut self) -> ::protobuf::RepeatedField<super::instance::InstanceID> {
        ::std::mem::replace(&mut self.final_deps, ::protobuf::RepeatedField::new())
    }

    // bool committed = 51;


    pub fn get_committed(&self) -> bool {
        self.committed
    }
    pub fn clear_committed(&mut self) {
        self.committed = false;
    }

    // Param is passed by value, moved
    pub fn set_committed(&mut self, v: bool) {
        self.committed = v;
    }
}

impl ::protobuf::Message for Reply {
    fn is_initialized(&self) -> bool {
        for v in &self.last_ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instance_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.final_deps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.req_type, 1, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_ballot)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_id)?;
                },
                32 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deps)?;
                },
                33 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.deps_committed)?;
                },
                41 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.final_deps)?;
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.committed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.req_type != RequestType::Prepare {
            my_size += ::protobuf::rt::enum_size(1, self.req_type);
        }
        if let Some(ref v) = self.last_ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.deps {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += 3 * self.deps_committed.len() as u32;
        for value in &self.final_deps {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.committed != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.req_type != RequestType::Prepare {
            os.write_enum(1, self.req_type.value())?;
        }
        if let Some(ref v) = self.last_ballot.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.deps {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.deps_committed {
            os.write_bool(33, *v)?;
        };
        for v in &self.final_deps {
            os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.committed != false {
            os.write_bool(51, self.committed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Reply {
        Reply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RequestType>>(
                    "req_type",
                    |m: &Reply| { &m.req_type },
                    |m: &mut Reply| { &mut m.req_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::BallotNum>>(
                    "last_ballot",
                    |m: &Reply| { &m.last_ballot },
                    |m: &mut Reply| { &mut m.last_ballot },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "instance_id",
                    |m: &Reply| { &m.instance_id },
                    |m: &mut Reply| { &mut m.instance_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "deps",
                    |m: &Reply| { &m.deps },
                    |m: &mut Reply| { &mut m.deps },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "deps_committed",
                    |m: &Reply| { &m.deps_committed },
                    |m: &mut Reply| { &mut m.deps_committed },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "final_deps",
                    |m: &Reply| { &m.final_deps },
                    |m: &mut Reply| { &mut m.final_deps },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "committed",
                    |m: &Reply| { &m.committed },
                    |m: &mut Reply| { &mut m.committed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Reply>(
                    "Reply",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Reply {
        static mut instance: ::protobuf::lazy::Lazy<Reply> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Reply,
        };
        unsafe {
            instance.get(Reply::new)
        }
    }
}

impl ::protobuf::Clear for Reply {
    fn clear(&mut self) {
        self.req_type = RequestType::Prepare;
        self.last_ballot.clear();
        self.instance_id.clear();
        self.deps.clear();
        self.deps_committed.clear();
        self.final_deps.clear();
        self.committed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Reply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Reply {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrepareReq {
    // message fields
    pub leader_id: i64,
    pub replica_id: i64,
    pub instance_id: ::protobuf::SingularPtrField<super::instance::InstanceID>,
    pub ballot: ::protobuf::SingularPtrField<super::instance::BallotNum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrepareReq {
    fn default() -> &'a PrepareReq {
        <PrepareReq as ::protobuf::Message>::default_instance()
    }
}

impl PrepareReq {
    pub fn new() -> PrepareReq {
        ::std::default::Default::default()
    }

    // int64 leader_id = 1;


    pub fn get_leader_id(&self) -> i64 {
        self.leader_id
    }
    pub fn clear_leader_id(&mut self) {
        self.leader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: i64) {
        self.leader_id = v;
    }

    // int64 replica_id = 2;


    pub fn get_replica_id(&self) -> i64 {
        self.replica_id
    }
    pub fn clear_replica_id(&mut self) {
        self.replica_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica_id(&mut self, v: i64) {
        self.replica_id = v;
    }

    // .InstanceID instance_id = 3;


    pub fn get_instance_id(&self) -> &super::instance::InstanceID {
        self.instance_id.as_ref().unwrap_or_else(|| super::instance::InstanceID::default_instance())
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id.clear();
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: super::instance::InstanceID) {
        self.instance_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_id(&mut self) -> &mut super::instance::InstanceID {
        if self.instance_id.is_none() {
            self.instance_id.set_default();
        }
        self.instance_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_id(&mut self) -> super::instance::InstanceID {
        self.instance_id.take().unwrap_or_else(|| super::instance::InstanceID::new())
    }

    // .BallotNum ballot = 4;


    pub fn get_ballot(&self) -> &super::instance::BallotNum {
        self.ballot.as_ref().unwrap_or_else(|| super::instance::BallotNum::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: super::instance::BallotNum) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut super::instance::BallotNum {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> super::instance::BallotNum {
        self.ballot.take().unwrap_or_else(|| super::instance::BallotNum::new())
    }
}

impl ::protobuf::Message for PrepareReq {
    fn is_initialized(&self) -> bool {
        for v in &self.instance_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.leader_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replica_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.leader_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.leader_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.replica_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.replica_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.leader_id != 0 {
            os.write_int64(1, self.leader_id)?;
        }
        if self.replica_id != 0 {
            os.write_int64(2, self.replica_id)?;
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrepareReq {
        PrepareReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "leader_id",
                    |m: &PrepareReq| { &m.leader_id },
                    |m: &mut PrepareReq| { &mut m.leader_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "replica_id",
                    |m: &PrepareReq| { &m.replica_id },
                    |m: &mut PrepareReq| { &mut m.replica_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "instance_id",
                    |m: &PrepareReq| { &m.instance_id },
                    |m: &mut PrepareReq| { &mut m.instance_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::BallotNum>>(
                    "ballot",
                    |m: &PrepareReq| { &m.ballot },
                    |m: &mut PrepareReq| { &mut m.ballot },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PrepareReq>(
                    "PrepareReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PrepareReq {
        static mut instance: ::protobuf::lazy::Lazy<PrepareReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PrepareReq,
        };
        unsafe {
            instance.get(PrepareReq::new)
        }
    }
}

impl ::protobuf::Clear for PrepareReq {
    fn clear(&mut self) {
        self.leader_id = 0;
        self.replica_id = 0;
        self.instance_id.clear();
        self.ballot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrepareReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrepareReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrepareReply {
    // message fields
    pub acceptor_id: i64,
    pub replica_id: i64,
    pub instance_id: ::protobuf::SingularPtrField<super::instance::InstanceID>,
    pub ok: bool,
    pub ballot: ::protobuf::SingularPtrField<super::instance::BallotNum>,
    pub instance: ::protobuf::SingularPtrField<super::instance::Instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrepareReply {
    fn default() -> &'a PrepareReply {
        <PrepareReply as ::protobuf::Message>::default_instance()
    }
}

impl PrepareReply {
    pub fn new() -> PrepareReply {
        ::std::default::Default::default()
    }

    // int64 acceptor_id = 1;


    pub fn get_acceptor_id(&self) -> i64 {
        self.acceptor_id
    }
    pub fn clear_acceptor_id(&mut self) {
        self.acceptor_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_acceptor_id(&mut self, v: i64) {
        self.acceptor_id = v;
    }

    // int64 replica_id = 2;


    pub fn get_replica_id(&self) -> i64 {
        self.replica_id
    }
    pub fn clear_replica_id(&mut self) {
        self.replica_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica_id(&mut self, v: i64) {
        self.replica_id = v;
    }

    // .InstanceID instance_id = 3;


    pub fn get_instance_id(&self) -> &super::instance::InstanceID {
        self.instance_id.as_ref().unwrap_or_else(|| super::instance::InstanceID::default_instance())
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id.clear();
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: super::instance::InstanceID) {
        self.instance_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_id(&mut self) -> &mut super::instance::InstanceID {
        if self.instance_id.is_none() {
            self.instance_id.set_default();
        }
        self.instance_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_id(&mut self) -> super::instance::InstanceID {
        self.instance_id.take().unwrap_or_else(|| super::instance::InstanceID::new())
    }

    // bool ok = 4;


    pub fn get_ok(&self) -> bool {
        self.ok
    }
    pub fn clear_ok(&mut self) {
        self.ok = false;
    }

    // Param is passed by value, moved
    pub fn set_ok(&mut self, v: bool) {
        self.ok = v;
    }

    // .BallotNum ballot = 5;


    pub fn get_ballot(&self) -> &super::instance::BallotNum {
        self.ballot.as_ref().unwrap_or_else(|| super::instance::BallotNum::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: super::instance::BallotNum) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut super::instance::BallotNum {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> super::instance::BallotNum {
        self.ballot.take().unwrap_or_else(|| super::instance::BallotNum::new())
    }

    // .Instance instance = 6;


    pub fn get_instance(&self) -> &super::instance::Instance {
        self.instance.as_ref().unwrap_or_else(|| super::instance::Instance::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: super::instance::Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut super::instance::Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> super::instance::Instance {
        self.instance.take().unwrap_or_else(|| super::instance::Instance::new())
    }
}

impl ::protobuf::Message for PrepareReply {
    fn is_initialized(&self) -> bool {
        for v in &self.instance_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.acceptor_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replica_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ok = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.acceptor_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.acceptor_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.replica_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.replica_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ok != false {
            my_size += 2;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.acceptor_id != 0 {
            os.write_int64(1, self.acceptor_id)?;
        }
        if self.replica_id != 0 {
            os.write_int64(2, self.replica_id)?;
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ok != false {
            os.write_bool(4, self.ok)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrepareReply {
        PrepareReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "acceptor_id",
                    |m: &PrepareReply| { &m.acceptor_id },
                    |m: &mut PrepareReply| { &mut m.acceptor_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "replica_id",
                    |m: &PrepareReply| { &m.replica_id },
                    |m: &mut PrepareReply| { &mut m.replica_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "instance_id",
                    |m: &PrepareReply| { &m.instance_id },
                    |m: &mut PrepareReply| { &mut m.instance_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ok",
                    |m: &PrepareReply| { &m.ok },
                    |m: &mut PrepareReply| { &mut m.ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::BallotNum>>(
                    "ballot",
                    |m: &PrepareReply| { &m.ballot },
                    |m: &mut PrepareReply| { &mut m.ballot },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::Instance>>(
                    "instance",
                    |m: &PrepareReply| { &m.instance },
                    |m: &mut PrepareReply| { &mut m.instance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PrepareReply>(
                    "PrepareReply",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PrepareReply {
        static mut instance: ::protobuf::lazy::Lazy<PrepareReply> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PrepareReply,
        };
        unsafe {
            instance.get(PrepareReply::new)
        }
    }
}

impl ::protobuf::Clear for PrepareReply {
    fn clear(&mut self) {
        self.acceptor_id = 0;
        self.replica_id = 0;
        self.instance_id.clear();
        self.ok = false;
        self.ballot.clear();
        self.instance.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrepareReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrepareReply {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreAcceptReq {
    // message fields
    pub leader_id: i64,
    pub replica_id: i64,
    pub instance_id: ::protobuf::SingularPtrField<super::instance::InstanceID>,
    pub instance: ::protobuf::SingularPtrField<super::instance::Instance>,
    pub ballot: ::protobuf::SingularPtrField<super::instance::BallotNum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreAcceptReq {
    fn default() -> &'a PreAcceptReq {
        <PreAcceptReq as ::protobuf::Message>::default_instance()
    }
}

impl PreAcceptReq {
    pub fn new() -> PreAcceptReq {
        ::std::default::Default::default()
    }

    // int64 leader_id = 1;


    pub fn get_leader_id(&self) -> i64 {
        self.leader_id
    }
    pub fn clear_leader_id(&mut self) {
        self.leader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: i64) {
        self.leader_id = v;
    }

    // int64 replica_id = 2;


    pub fn get_replica_id(&self) -> i64 {
        self.replica_id
    }
    pub fn clear_replica_id(&mut self) {
        self.replica_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica_id(&mut self, v: i64) {
        self.replica_id = v;
    }

    // .InstanceID instance_id = 3;


    pub fn get_instance_id(&self) -> &super::instance::InstanceID {
        self.instance_id.as_ref().unwrap_or_else(|| super::instance::InstanceID::default_instance())
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id.clear();
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: super::instance::InstanceID) {
        self.instance_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_id(&mut self) -> &mut super::instance::InstanceID {
        if self.instance_id.is_none() {
            self.instance_id.set_default();
        }
        self.instance_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_id(&mut self) -> super::instance::InstanceID {
        self.instance_id.take().unwrap_or_else(|| super::instance::InstanceID::new())
    }

    // .Instance instance = 4;


    pub fn get_instance(&self) -> &super::instance::Instance {
        self.instance.as_ref().unwrap_or_else(|| super::instance::Instance::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: super::instance::Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut super::instance::Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> super::instance::Instance {
        self.instance.take().unwrap_or_else(|| super::instance::Instance::new())
    }

    // .BallotNum ballot = 5;


    pub fn get_ballot(&self) -> &super::instance::BallotNum {
        self.ballot.as_ref().unwrap_or_else(|| super::instance::BallotNum::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: super::instance::BallotNum) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut super::instance::BallotNum {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> super::instance::BallotNum {
        self.ballot.take().unwrap_or_else(|| super::instance::BallotNum::new())
    }
}

impl ::protobuf::Message for PreAcceptReq {
    fn is_initialized(&self) -> bool {
        for v in &self.instance_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.leader_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replica_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.leader_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.leader_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.replica_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.replica_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.leader_id != 0 {
            os.write_int64(1, self.leader_id)?;
        }
        if self.replica_id != 0 {
            os.write_int64(2, self.replica_id)?;
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreAcceptReq {
        PreAcceptReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "leader_id",
                    |m: &PreAcceptReq| { &m.leader_id },
                    |m: &mut PreAcceptReq| { &mut m.leader_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "replica_id",
                    |m: &PreAcceptReq| { &m.replica_id },
                    |m: &mut PreAcceptReq| { &mut m.replica_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "instance_id",
                    |m: &PreAcceptReq| { &m.instance_id },
                    |m: &mut PreAcceptReq| { &mut m.instance_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::Instance>>(
                    "instance",
                    |m: &PreAcceptReq| { &m.instance },
                    |m: &mut PreAcceptReq| { &mut m.instance },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::BallotNum>>(
                    "ballot",
                    |m: &PreAcceptReq| { &m.ballot },
                    |m: &mut PreAcceptReq| { &mut m.ballot },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PreAcceptReq>(
                    "PreAcceptReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PreAcceptReq {
        static mut instance: ::protobuf::lazy::Lazy<PreAcceptReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PreAcceptReq,
        };
        unsafe {
            instance.get(PreAcceptReq::new)
        }
    }
}

impl ::protobuf::Clear for PreAcceptReq {
    fn clear(&mut self) {
        self.leader_id = 0;
        self.replica_id = 0;
        self.instance_id.clear();
        self.instance.clear();
        self.ballot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreAcceptReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreAcceptReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreAcceptReply {
    // message fields
    pub replica_id: i64,
    pub instance: ::protobuf::SingularPtrField<super::instance::Instance>,
    pub ok: bool,
    pub ballot: ::protobuf::SingularPtrField<super::instance::BallotNum>,
    pub committed_deps: ::protobuf::RepeatedField<super::instance::InstanceID>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreAcceptReply {
    fn default() -> &'a PreAcceptReply {
        <PreAcceptReply as ::protobuf::Message>::default_instance()
    }
}

impl PreAcceptReply {
    pub fn new() -> PreAcceptReply {
        ::std::default::Default::default()
    }

    // int64 replica_id = 1;


    pub fn get_replica_id(&self) -> i64 {
        self.replica_id
    }
    pub fn clear_replica_id(&mut self) {
        self.replica_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica_id(&mut self, v: i64) {
        self.replica_id = v;
    }

    // .Instance instance = 2;


    pub fn get_instance(&self) -> &super::instance::Instance {
        self.instance.as_ref().unwrap_or_else(|| super::instance::Instance::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: super::instance::Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut super::instance::Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> super::instance::Instance {
        self.instance.take().unwrap_or_else(|| super::instance::Instance::new())
    }

    // bool ok = 3;


    pub fn get_ok(&self) -> bool {
        self.ok
    }
    pub fn clear_ok(&mut self) {
        self.ok = false;
    }

    // Param is passed by value, moved
    pub fn set_ok(&mut self, v: bool) {
        self.ok = v;
    }

    // .BallotNum ballot = 4;


    pub fn get_ballot(&self) -> &super::instance::BallotNum {
        self.ballot.as_ref().unwrap_or_else(|| super::instance::BallotNum::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: super::instance::BallotNum) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut super::instance::BallotNum {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> super::instance::BallotNum {
        self.ballot.take().unwrap_or_else(|| super::instance::BallotNum::new())
    }

    // repeated .InstanceID committed_deps = 5;


    pub fn get_committed_deps(&self) -> &[super::instance::InstanceID] {
        &self.committed_deps
    }
    pub fn clear_committed_deps(&mut self) {
        self.committed_deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_committed_deps(&mut self, v: ::protobuf::RepeatedField<super::instance::InstanceID>) {
        self.committed_deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_committed_deps(&mut self) -> &mut ::protobuf::RepeatedField<super::instance::InstanceID> {
        &mut self.committed_deps
    }

    // Take field
    pub fn take_committed_deps(&mut self) -> ::protobuf::RepeatedField<super::instance::InstanceID> {
        ::std::mem::replace(&mut self.committed_deps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PreAcceptReply {
    fn is_initialized(&self) -> bool {
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.committed_deps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replica_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ok = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.committed_deps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.replica_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.replica_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ok != false {
            my_size += 2;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.committed_deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.replica_id != 0 {
            os.write_int64(1, self.replica_id)?;
        }
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ok != false {
            os.write_bool(3, self.ok)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.committed_deps {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreAcceptReply {
        PreAcceptReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "replica_id",
                    |m: &PreAcceptReply| { &m.replica_id },
                    |m: &mut PreAcceptReply| { &mut m.replica_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::Instance>>(
                    "instance",
                    |m: &PreAcceptReply| { &m.instance },
                    |m: &mut PreAcceptReply| { &mut m.instance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ok",
                    |m: &PreAcceptReply| { &m.ok },
                    |m: &mut PreAcceptReply| { &mut m.ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::BallotNum>>(
                    "ballot",
                    |m: &PreAcceptReply| { &m.ballot },
                    |m: &mut PreAcceptReply| { &mut m.ballot },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "committed_deps",
                    |m: &PreAcceptReply| { &m.committed_deps },
                    |m: &mut PreAcceptReply| { &mut m.committed_deps },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PreAcceptReply>(
                    "PreAcceptReply",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PreAcceptReply {
        static mut instance: ::protobuf::lazy::Lazy<PreAcceptReply> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PreAcceptReply,
        };
        unsafe {
            instance.get(PreAcceptReply::new)
        }
    }
}

impl ::protobuf::Clear for PreAcceptReply {
    fn clear(&mut self) {
        self.replica_id = 0;
        self.instance.clear();
        self.ok = false;
        self.ballot.clear();
        self.committed_deps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreAcceptReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreAcceptReply {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AcceptReq {
    // message fields
    pub leader_id: i64,
    pub replica_id: i64,
    pub instance: ::protobuf::SingularPtrField<super::instance::Instance>,
    pub ballot: ::protobuf::SingularPtrField<super::instance::BallotNum>,
    pub count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AcceptReq {
    fn default() -> &'a AcceptReq {
        <AcceptReq as ::protobuf::Message>::default_instance()
    }
}

impl AcceptReq {
    pub fn new() -> AcceptReq {
        ::std::default::Default::default()
    }

    // int64 leader_id = 1;


    pub fn get_leader_id(&self) -> i64 {
        self.leader_id
    }
    pub fn clear_leader_id(&mut self) {
        self.leader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: i64) {
        self.leader_id = v;
    }

    // int64 replica_id = 2;


    pub fn get_replica_id(&self) -> i64 {
        self.replica_id
    }
    pub fn clear_replica_id(&mut self) {
        self.replica_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica_id(&mut self, v: i64) {
        self.replica_id = v;
    }

    // .Instance instance = 3;


    pub fn get_instance(&self) -> &super::instance::Instance {
        self.instance.as_ref().unwrap_or_else(|| super::instance::Instance::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: super::instance::Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut super::instance::Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> super::instance::Instance {
        self.instance.take().unwrap_or_else(|| super::instance::Instance::new())
    }

    // .BallotNum ballot = 4;


    pub fn get_ballot(&self) -> &super::instance::BallotNum {
        self.ballot.as_ref().unwrap_or_else(|| super::instance::BallotNum::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: super::instance::BallotNum) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut super::instance::BallotNum {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> super::instance::BallotNum {
        self.ballot.take().unwrap_or_else(|| super::instance::BallotNum::new())
    }

    // int32 count = 5;


    pub fn get_count(&self) -> i32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = v;
    }
}

impl ::protobuf::Message for AcceptReq {
    fn is_initialized(&self) -> bool {
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.leader_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replica_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.leader_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.leader_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.replica_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.replica_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(5, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.leader_id != 0 {
            os.write_int64(1, self.leader_id)?;
        }
        if self.replica_id != 0 {
            os.write_int64(2, self.replica_id)?;
        }
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.count != 0 {
            os.write_int32(5, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AcceptReq {
        AcceptReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "leader_id",
                    |m: &AcceptReq| { &m.leader_id },
                    |m: &mut AcceptReq| { &mut m.leader_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "replica_id",
                    |m: &AcceptReq| { &m.replica_id },
                    |m: &mut AcceptReq| { &mut m.replica_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::Instance>>(
                    "instance",
                    |m: &AcceptReq| { &m.instance },
                    |m: &mut AcceptReq| { &mut m.instance },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::BallotNum>>(
                    "ballot",
                    |m: &AcceptReq| { &m.ballot },
                    |m: &mut AcceptReq| { &mut m.ballot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "count",
                    |m: &AcceptReq| { &m.count },
                    |m: &mut AcceptReq| { &mut m.count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AcceptReq>(
                    "AcceptReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AcceptReq {
        static mut instance: ::protobuf::lazy::Lazy<AcceptReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AcceptReq,
        };
        unsafe {
            instance.get(AcceptReq::new)
        }
    }
}

impl ::protobuf::Clear for AcceptReq {
    fn clear(&mut self) {
        self.leader_id = 0;
        self.replica_id = 0;
        self.instance.clear();
        self.ballot.clear();
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AcceptReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AcceptReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AcceptReply {
    // message fields
    pub replica_id: i64,
    pub instance_id: ::protobuf::SingularPtrField<super::instance::InstanceID>,
    pub ok: bool,
    pub ballot: ::protobuf::SingularPtrField<super::instance::BallotNum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AcceptReply {
    fn default() -> &'a AcceptReply {
        <AcceptReply as ::protobuf::Message>::default_instance()
    }
}

impl AcceptReply {
    pub fn new() -> AcceptReply {
        ::std::default::Default::default()
    }

    // int64 replica_id = 1;


    pub fn get_replica_id(&self) -> i64 {
        self.replica_id
    }
    pub fn clear_replica_id(&mut self) {
        self.replica_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica_id(&mut self, v: i64) {
        self.replica_id = v;
    }

    // .InstanceID instance_id = 2;


    pub fn get_instance_id(&self) -> &super::instance::InstanceID {
        self.instance_id.as_ref().unwrap_or_else(|| super::instance::InstanceID::default_instance())
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id.clear();
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: super::instance::InstanceID) {
        self.instance_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_id(&mut self) -> &mut super::instance::InstanceID {
        if self.instance_id.is_none() {
            self.instance_id.set_default();
        }
        self.instance_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_id(&mut self) -> super::instance::InstanceID {
        self.instance_id.take().unwrap_or_else(|| super::instance::InstanceID::new())
    }

    // bool ok = 3;


    pub fn get_ok(&self) -> bool {
        self.ok
    }
    pub fn clear_ok(&mut self) {
        self.ok = false;
    }

    // Param is passed by value, moved
    pub fn set_ok(&mut self, v: bool) {
        self.ok = v;
    }

    // .BallotNum ballot = 4;


    pub fn get_ballot(&self) -> &super::instance::BallotNum {
        self.ballot.as_ref().unwrap_or_else(|| super::instance::BallotNum::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: super::instance::BallotNum) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut super::instance::BallotNum {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> super::instance::BallotNum {
        self.ballot.take().unwrap_or_else(|| super::instance::BallotNum::new())
    }
}

impl ::protobuf::Message for AcceptReply {
    fn is_initialized(&self) -> bool {
        for v in &self.instance_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replica_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ok = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.replica_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.replica_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ok != false {
            my_size += 2;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.replica_id != 0 {
            os.write_int64(1, self.replica_id)?;
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ok != false {
            os.write_bool(3, self.ok)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AcceptReply {
        AcceptReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "replica_id",
                    |m: &AcceptReply| { &m.replica_id },
                    |m: &mut AcceptReply| { &mut m.replica_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "instance_id",
                    |m: &AcceptReply| { &m.instance_id },
                    |m: &mut AcceptReply| { &mut m.instance_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ok",
                    |m: &AcceptReply| { &m.ok },
                    |m: &mut AcceptReply| { &mut m.ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::BallotNum>>(
                    "ballot",
                    |m: &AcceptReply| { &m.ballot },
                    |m: &mut AcceptReply| { &mut m.ballot },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AcceptReply>(
                    "AcceptReply",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AcceptReply {
        static mut instance: ::protobuf::lazy::Lazy<AcceptReply> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AcceptReply,
        };
        unsafe {
            instance.get(AcceptReply::new)
        }
    }
}

impl ::protobuf::Clear for AcceptReply {
    fn clear(&mut self) {
        self.replica_id = 0;
        self.instance_id.clear();
        self.ok = false;
        self.ballot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AcceptReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AcceptReply {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitReq {
    // message fields
    pub leader_id: i64,
    pub replica_id: i64,
    pub instance: ::protobuf::SingularPtrField<super::instance::Instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitReq {
    fn default() -> &'a CommitReq {
        <CommitReq as ::protobuf::Message>::default_instance()
    }
}

impl CommitReq {
    pub fn new() -> CommitReq {
        ::std::default::Default::default()
    }

    // int64 leader_id = 1;


    pub fn get_leader_id(&self) -> i64 {
        self.leader_id
    }
    pub fn clear_leader_id(&mut self) {
        self.leader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: i64) {
        self.leader_id = v;
    }

    // int64 replica_id = 2;


    pub fn get_replica_id(&self) -> i64 {
        self.replica_id
    }
    pub fn clear_replica_id(&mut self) {
        self.replica_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica_id(&mut self, v: i64) {
        self.replica_id = v;
    }

    // .Instance instance = 3;


    pub fn get_instance(&self) -> &super::instance::Instance {
        self.instance.as_ref().unwrap_or_else(|| super::instance::Instance::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: super::instance::Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut super::instance::Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> super::instance::Instance {
        self.instance.take().unwrap_or_else(|| super::instance::Instance::new())
    }
}

impl ::protobuf::Message for CommitReq {
    fn is_initialized(&self) -> bool {
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.leader_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replica_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.leader_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.leader_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.replica_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.replica_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.leader_id != 0 {
            os.write_int64(1, self.leader_id)?;
        }
        if self.replica_id != 0 {
            os.write_int64(2, self.replica_id)?;
        }
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitReq {
        CommitReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "leader_id",
                    |m: &CommitReq| { &m.leader_id },
                    |m: &mut CommitReq| { &mut m.leader_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "replica_id",
                    |m: &CommitReq| { &m.replica_id },
                    |m: &mut CommitReq| { &mut m.replica_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::Instance>>(
                    "instance",
                    |m: &CommitReq| { &m.instance },
                    |m: &mut CommitReq| { &mut m.instance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommitReq>(
                    "CommitReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommitReq {
        static mut instance: ::protobuf::lazy::Lazy<CommitReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommitReq,
        };
        unsafe {
            instance.get(CommitReq::new)
        }
    }
}

impl ::protobuf::Clear for CommitReq {
    fn clear(&mut self) {
        self.leader_id = 0;
        self.replica_id = 0;
        self.instance.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitShort {
    // message fields
    pub leader_id: i64,
    pub replica_id: i64,
    pub instance_id: ::protobuf::SingularPtrField<super::instance::InstanceID>,
    pub count: i32,
    pub seq: i32,
    pub deps: ::protobuf::RepeatedField<super::instance::InstanceID>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitShort {
    fn default() -> &'a CommitShort {
        <CommitShort as ::protobuf::Message>::default_instance()
    }
}

impl CommitShort {
    pub fn new() -> CommitShort {
        ::std::default::Default::default()
    }

    // int64 leader_id = 1;


    pub fn get_leader_id(&self) -> i64 {
        self.leader_id
    }
    pub fn clear_leader_id(&mut self) {
        self.leader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: i64) {
        self.leader_id = v;
    }

    // int64 replica_id = 2;


    pub fn get_replica_id(&self) -> i64 {
        self.replica_id
    }
    pub fn clear_replica_id(&mut self) {
        self.replica_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica_id(&mut self, v: i64) {
        self.replica_id = v;
    }

    // .InstanceID instance_id = 3;


    pub fn get_instance_id(&self) -> &super::instance::InstanceID {
        self.instance_id.as_ref().unwrap_or_else(|| super::instance::InstanceID::default_instance())
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id.clear();
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: super::instance::InstanceID) {
        self.instance_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_id(&mut self) -> &mut super::instance::InstanceID {
        if self.instance_id.is_none() {
            self.instance_id.set_default();
        }
        self.instance_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_id(&mut self) -> super::instance::InstanceID {
        self.instance_id.take().unwrap_or_else(|| super::instance::InstanceID::new())
    }

    // int32 count = 4;


    pub fn get_count(&self) -> i32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = v;
    }

    // int32 seq = 5;


    pub fn get_seq(&self) -> i32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: i32) {
        self.seq = v;
    }

    // repeated .InstanceID deps = 6;


    pub fn get_deps(&self) -> &[super::instance::InstanceID] {
        &self.deps
    }
    pub fn clear_deps(&mut self) {
        self.deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_deps(&mut self, v: ::protobuf::RepeatedField<super::instance::InstanceID>) {
        self.deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deps(&mut self) -> &mut ::protobuf::RepeatedField<super::instance::InstanceID> {
        &mut self.deps
    }

    // Take field
    pub fn take_deps(&mut self) -> ::protobuf::RepeatedField<super::instance::InstanceID> {
        ::std::mem::replace(&mut self.deps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CommitShort {
    fn is_initialized(&self) -> bool {
        for v in &self.instance_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.leader_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replica_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seq = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.leader_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.leader_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.replica_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.replica_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(4, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(5, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.leader_id != 0 {
            os.write_int64(1, self.leader_id)?;
        }
        if self.replica_id != 0 {
            os.write_int64(2, self.replica_id)?;
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.count != 0 {
            os.write_int32(4, self.count)?;
        }
        if self.seq != 0 {
            os.write_int32(5, self.seq)?;
        }
        for v in &self.deps {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitShort {
        CommitShort::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "leader_id",
                    |m: &CommitShort| { &m.leader_id },
                    |m: &mut CommitShort| { &mut m.leader_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "replica_id",
                    |m: &CommitShort| { &m.replica_id },
                    |m: &mut CommitShort| { &mut m.replica_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "instance_id",
                    |m: &CommitShort| { &m.instance_id },
                    |m: &mut CommitShort| { &mut m.instance_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "count",
                    |m: &CommitShort| { &m.count },
                    |m: &mut CommitShort| { &mut m.count },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "seq",
                    |m: &CommitShort| { &m.seq },
                    |m: &mut CommitShort| { &mut m.seq },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "deps",
                    |m: &CommitShort| { &m.deps },
                    |m: &mut CommitShort| { &mut m.deps },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommitShort>(
                    "CommitShort",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommitShort {
        static mut instance: ::protobuf::lazy::Lazy<CommitShort> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommitShort,
        };
        unsafe {
            instance.get(CommitShort::new)
        }
    }
}

impl ::protobuf::Clear for CommitShort {
    fn clear(&mut self) {
        self.leader_id = 0;
        self.replica_id = 0;
        self.instance_id.clear();
        self.count = 0;
        self.seq = 0;
        self.deps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitShort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitShort {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TryPreAcceptReq {
    // message fields
    pub leader_id: i64,
    pub replica_id: i64,
    pub instance_id: ::protobuf::SingularPtrField<super::instance::InstanceID>,
    pub ballot: ::protobuf::SingularPtrField<super::instance::BallotNum>,
    pub instance: ::protobuf::SingularPtrField<super::instance::Instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TryPreAcceptReq {
    fn default() -> &'a TryPreAcceptReq {
        <TryPreAcceptReq as ::protobuf::Message>::default_instance()
    }
}

impl TryPreAcceptReq {
    pub fn new() -> TryPreAcceptReq {
        ::std::default::Default::default()
    }

    // int64 leader_id = 1;


    pub fn get_leader_id(&self) -> i64 {
        self.leader_id
    }
    pub fn clear_leader_id(&mut self) {
        self.leader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: i64) {
        self.leader_id = v;
    }

    // int64 replica_id = 2;


    pub fn get_replica_id(&self) -> i64 {
        self.replica_id
    }
    pub fn clear_replica_id(&mut self) {
        self.replica_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica_id(&mut self, v: i64) {
        self.replica_id = v;
    }

    // .InstanceID instance_id = 3;


    pub fn get_instance_id(&self) -> &super::instance::InstanceID {
        self.instance_id.as_ref().unwrap_or_else(|| super::instance::InstanceID::default_instance())
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id.clear();
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: super::instance::InstanceID) {
        self.instance_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_id(&mut self) -> &mut super::instance::InstanceID {
        if self.instance_id.is_none() {
            self.instance_id.set_default();
        }
        self.instance_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_id(&mut self) -> super::instance::InstanceID {
        self.instance_id.take().unwrap_or_else(|| super::instance::InstanceID::new())
    }

    // .BallotNum ballot = 4;


    pub fn get_ballot(&self) -> &super::instance::BallotNum {
        self.ballot.as_ref().unwrap_or_else(|| super::instance::BallotNum::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: super::instance::BallotNum) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut super::instance::BallotNum {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> super::instance::BallotNum {
        self.ballot.take().unwrap_or_else(|| super::instance::BallotNum::new())
    }

    // .Instance instance = 5;


    pub fn get_instance(&self) -> &super::instance::Instance {
        self.instance.as_ref().unwrap_or_else(|| super::instance::Instance::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: super::instance::Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut super::instance::Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> super::instance::Instance {
        self.instance.take().unwrap_or_else(|| super::instance::Instance::new())
    }
}

impl ::protobuf::Message for TryPreAcceptReq {
    fn is_initialized(&self) -> bool {
        for v in &self.instance_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.leader_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replica_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.leader_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.leader_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.replica_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.replica_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.leader_id != 0 {
            os.write_int64(1, self.leader_id)?;
        }
        if self.replica_id != 0 {
            os.write_int64(2, self.replica_id)?;
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TryPreAcceptReq {
        TryPreAcceptReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "leader_id",
                    |m: &TryPreAcceptReq| { &m.leader_id },
                    |m: &mut TryPreAcceptReq| { &mut m.leader_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "replica_id",
                    |m: &TryPreAcceptReq| { &m.replica_id },
                    |m: &mut TryPreAcceptReq| { &mut m.replica_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "instance_id",
                    |m: &TryPreAcceptReq| { &m.instance_id },
                    |m: &mut TryPreAcceptReq| { &mut m.instance_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::BallotNum>>(
                    "ballot",
                    |m: &TryPreAcceptReq| { &m.ballot },
                    |m: &mut TryPreAcceptReq| { &mut m.ballot },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::Instance>>(
                    "instance",
                    |m: &TryPreAcceptReq| { &m.instance },
                    |m: &mut TryPreAcceptReq| { &mut m.instance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TryPreAcceptReq>(
                    "TryPreAcceptReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TryPreAcceptReq {
        static mut instance: ::protobuf::lazy::Lazy<TryPreAcceptReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TryPreAcceptReq,
        };
        unsafe {
            instance.get(TryPreAcceptReq::new)
        }
    }
}

impl ::protobuf::Clear for TryPreAcceptReq {
    fn clear(&mut self) {
        self.leader_id = 0;
        self.replica_id = 0;
        self.instance_id.clear();
        self.ballot.clear();
        self.instance.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TryPreAcceptReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TryPreAcceptReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TryPreAcceptReply {
    // message fields
    pub acceptor_id: i64,
    pub replica_id: i64,
    pub instance_id: ::protobuf::SingularPtrField<super::instance::InstanceID>,
    pub ok: bool,
    pub ballot: ::protobuf::SingularPtrField<super::instance::BallotNum>,
    pub conflict_replica: i64,
    pub conflict_instance_id: ::protobuf::SingularPtrField<super::instance::InstanceID>,
    pub conflict_status: super::instance::InstanceStatus,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TryPreAcceptReply {
    fn default() -> &'a TryPreAcceptReply {
        <TryPreAcceptReply as ::protobuf::Message>::default_instance()
    }
}

impl TryPreAcceptReply {
    pub fn new() -> TryPreAcceptReply {
        ::std::default::Default::default()
    }

    // int64 acceptor_id = 1;


    pub fn get_acceptor_id(&self) -> i64 {
        self.acceptor_id
    }
    pub fn clear_acceptor_id(&mut self) {
        self.acceptor_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_acceptor_id(&mut self, v: i64) {
        self.acceptor_id = v;
    }

    // int64 replica_id = 2;


    pub fn get_replica_id(&self) -> i64 {
        self.replica_id
    }
    pub fn clear_replica_id(&mut self) {
        self.replica_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica_id(&mut self, v: i64) {
        self.replica_id = v;
    }

    // .InstanceID instance_id = 3;


    pub fn get_instance_id(&self) -> &super::instance::InstanceID {
        self.instance_id.as_ref().unwrap_or_else(|| super::instance::InstanceID::default_instance())
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id.clear();
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: super::instance::InstanceID) {
        self.instance_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_id(&mut self) -> &mut super::instance::InstanceID {
        if self.instance_id.is_none() {
            self.instance_id.set_default();
        }
        self.instance_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_id(&mut self) -> super::instance::InstanceID {
        self.instance_id.take().unwrap_or_else(|| super::instance::InstanceID::new())
    }

    // bool ok = 4;


    pub fn get_ok(&self) -> bool {
        self.ok
    }
    pub fn clear_ok(&mut self) {
        self.ok = false;
    }

    // Param is passed by value, moved
    pub fn set_ok(&mut self, v: bool) {
        self.ok = v;
    }

    // .BallotNum ballot = 5;


    pub fn get_ballot(&self) -> &super::instance::BallotNum {
        self.ballot.as_ref().unwrap_or_else(|| super::instance::BallotNum::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: super::instance::BallotNum) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut super::instance::BallotNum {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> super::instance::BallotNum {
        self.ballot.take().unwrap_or_else(|| super::instance::BallotNum::new())
    }

    // int64 conflict_replica = 6;


    pub fn get_conflict_replica(&self) -> i64 {
        self.conflict_replica
    }
    pub fn clear_conflict_replica(&mut self) {
        self.conflict_replica = 0;
    }

    // Param is passed by value, moved
    pub fn set_conflict_replica(&mut self, v: i64) {
        self.conflict_replica = v;
    }

    // .InstanceID conflict_instance_id = 7;


    pub fn get_conflict_instance_id(&self) -> &super::instance::InstanceID {
        self.conflict_instance_id.as_ref().unwrap_or_else(|| super::instance::InstanceID::default_instance())
    }
    pub fn clear_conflict_instance_id(&mut self) {
        self.conflict_instance_id.clear();
    }

    pub fn has_conflict_instance_id(&self) -> bool {
        self.conflict_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conflict_instance_id(&mut self, v: super::instance::InstanceID) {
        self.conflict_instance_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conflict_instance_id(&mut self) -> &mut super::instance::InstanceID {
        if self.conflict_instance_id.is_none() {
            self.conflict_instance_id.set_default();
        }
        self.conflict_instance_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_conflict_instance_id(&mut self) -> super::instance::InstanceID {
        self.conflict_instance_id.take().unwrap_or_else(|| super::instance::InstanceID::new())
    }

    // .InstanceStatus conflict_status = 8;


    pub fn get_conflict_status(&self) -> super::instance::InstanceStatus {
        self.conflict_status
    }
    pub fn clear_conflict_status(&mut self) {
        self.conflict_status = super::instance::InstanceStatus::NA;
    }

    // Param is passed by value, moved
    pub fn set_conflict_status(&mut self, v: super::instance::InstanceStatus) {
        self.conflict_status = v;
    }
}

impl ::protobuf::Message for TryPreAcceptReply {
    fn is_initialized(&self) -> bool {
        for v in &self.instance_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conflict_instance_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.acceptor_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replica_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ok = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.conflict_replica = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conflict_instance_id)?;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.conflict_status, 8, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.acceptor_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.acceptor_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.replica_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.replica_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ok != false {
            my_size += 2;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.conflict_replica != 0 {
            my_size += ::protobuf::rt::value_size(6, self.conflict_replica, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.conflict_instance_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.conflict_status != super::instance::InstanceStatus::NA {
            my_size += ::protobuf::rt::enum_size(8, self.conflict_status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.acceptor_id != 0 {
            os.write_int64(1, self.acceptor_id)?;
        }
        if self.replica_id != 0 {
            os.write_int64(2, self.replica_id)?;
        }
        if let Some(ref v) = self.instance_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ok != false {
            os.write_bool(4, self.ok)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.conflict_replica != 0 {
            os.write_int64(6, self.conflict_replica)?;
        }
        if let Some(ref v) = self.conflict_instance_id.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.conflict_status != super::instance::InstanceStatus::NA {
            os.write_enum(8, self.conflict_status.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TryPreAcceptReply {
        TryPreAcceptReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "acceptor_id",
                    |m: &TryPreAcceptReply| { &m.acceptor_id },
                    |m: &mut TryPreAcceptReply| { &mut m.acceptor_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "replica_id",
                    |m: &TryPreAcceptReply| { &m.replica_id },
                    |m: &mut TryPreAcceptReply| { &mut m.replica_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "instance_id",
                    |m: &TryPreAcceptReply| { &m.instance_id },
                    |m: &mut TryPreAcceptReply| { &mut m.instance_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ok",
                    |m: &TryPreAcceptReply| { &m.ok },
                    |m: &mut TryPreAcceptReply| { &mut m.ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::BallotNum>>(
                    "ballot",
                    |m: &TryPreAcceptReply| { &m.ballot },
                    |m: &mut TryPreAcceptReply| { &mut m.ballot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "conflict_replica",
                    |m: &TryPreAcceptReply| { &m.conflict_replica },
                    |m: &mut TryPreAcceptReply| { &mut m.conflict_replica },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::instance::InstanceID>>(
                    "conflict_instance_id",
                    |m: &TryPreAcceptReply| { &m.conflict_instance_id },
                    |m: &mut TryPreAcceptReply| { &mut m.conflict_instance_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::instance::InstanceStatus>>(
                    "conflict_status",
                    |m: &TryPreAcceptReply| { &m.conflict_status },
                    |m: &mut TryPreAcceptReply| { &mut m.conflict_status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TryPreAcceptReply>(
                    "TryPreAcceptReply",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TryPreAcceptReply {
        static mut instance: ::protobuf::lazy::Lazy<TryPreAcceptReply> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TryPreAcceptReply,
        };
        unsafe {
            instance.get(TryPreAcceptReply::new)
        }
    }
}

impl ::protobuf::Clear for TryPreAcceptReply {
    fn clear(&mut self) {
        self.acceptor_id = 0;
        self.replica_id = 0;
        self.instance_id.clear();
        self.ok = false;
        self.ballot.clear();
        self.conflict_replica = 0;
        self.conflict_instance_id.clear();
        self.conflict_status = super::instance::InstanceStatus::NA;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TryPreAcceptReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TryPreAcceptReply {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RequestType {
    Prepare = 0,
    TryPreAccept = 1,
    PreAccept = 2,
    Accept = 3,
    Commit = 4,
}

impl ::protobuf::ProtobufEnum for RequestType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RequestType> {
        match value {
            0 => ::std::option::Option::Some(RequestType::Prepare),
            1 => ::std::option::Option::Some(RequestType::TryPreAccept),
            2 => ::std::option::Option::Some(RequestType::PreAccept),
            3 => ::std::option::Option::Some(RequestType::Accept),
            4 => ::std::option::Option::Some(RequestType::Commit),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RequestType] = &[
            RequestType::Prepare,
            RequestType::TryPreAccept,
            RequestType::PreAccept,
            RequestType::Accept,
            RequestType::Commit,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RequestType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RequestType {
}

impl ::std::default::Default for RequestType {
    fn default() -> Self {
        RequestType::Prepare
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MessageType {
    TypeRequest = 0,
    TypeReply = 1,
}

impl ::protobuf::ProtobufEnum for MessageType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageType> {
        match value {
            0 => ::std::option::Option::Some(MessageType::TypeRequest),
            1 => ::std::option::Option::Some(MessageType::TypeReply),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MessageType] = &[
            MessageType::TypeRequest,
            MessageType::TypeReply,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MessageType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MessageType {
}

impl ::std::default::Default for MessageType {
    fn default() -> Self {
        MessageType::TypeRequest
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rmessage.proto\x1a\rcommand.proto\x1a\x0einstance.proto\"o\n\x07Messa\
    ge\x12'\n\x08req_type\x18\x02\x20\x01(\x0e2\x0c.RequestTypeR\x07reqType\
    \x12'\n\x08msg_type\x18\x03\x20\x01(\x0e2\x0c.MessageTypeR\x07msgType\
    \x12\x12\n\x04data\x18\x04\x20\x01(\x0cR\x04data\"\xc9\x02\n\x07Request\
    \x12'\n\x08req_type\x18\x01\x20\x01(\x0e2\x0c.RequestTypeR\x07reqType\
    \x12\"\n\rto_replica_id\x18\x02\x20\x01(\x03R\x0btoReplicaId\x12\"\n\x06\
    ballot\x18\x0c\x20\x01(\x0b2\n.BallotNumR\x06ballot\x12,\n\x0binstance_i\
    d\x18\r\x20\x01(\x0b2\x0b.InstanceIDR\ninstanceId\x12\x1c\n\x04cmds\x18\
    \x15\x20\x03(\x0b2\x08.CommandR\x04cmds\x12.\n\x0cinitial_deps\x18\x1f\
    \x20\x03(\x0b2\x0b.InstanceIDR\x0binitialDeps\x12%\n\x0edeps_committed\
    \x18!\x20\x03(\x08R\rdepsCommitted\x12*\n\nfinal_deps\x18)\x20\x03(\x0b2\
    \x0b.InstanceIDR\tfinalDeps\"\x9d\x02\n\x05Reply\x12'\n\x08req_type\x18\
    \x01\x20\x01(\x0e2\x0c.RequestTypeR\x07reqType\x12+\n\x0blast_ballot\x18\
    \x0b\x20\x01(\x0b2\n.BallotNumR\nlastBallot\x12,\n\x0binstance_id\x18\r\
    \x20\x01(\x0b2\x0b.InstanceIDR\ninstanceId\x12\x1f\n\x04deps\x18\x20\x20\
    \x03(\x0b2\x0b.InstanceIDR\x04deps\x12%\n\x0edeps_committed\x18!\x20\x03\
    (\x08R\rdepsCommitted\x12*\n\nfinal_deps\x18)\x20\x03(\x0b2\x0b.Instance\
    IDR\tfinalDeps\x12\x1c\n\tcommitted\x183\x20\x01(\x08R\tcommitted\"\x9a\
    \x01\n\nPrepareReq\x12\x1b\n\tleader_id\x18\x01\x20\x01(\x03R\x08leaderI\
    d\x12\x1d\n\nreplica_id\x18\x02\x20\x01(\x03R\treplicaId\x12,\n\x0binsta\
    nce_id\x18\x03\x20\x01(\x0b2\x0b.InstanceIDR\ninstanceId\x12\"\n\x06ball\
    ot\x18\x04\x20\x01(\x0b2\n.BallotNumR\x06ballot\"\xd7\x01\n\x0cPrepareRe\
    ply\x12\x1f\n\x0bacceptor_id\x18\x01\x20\x01(\x03R\nacceptorId\x12\x1d\n\
    \nreplica_id\x18\x02\x20\x01(\x03R\treplicaId\x12,\n\x0binstance_id\x18\
    \x03\x20\x01(\x0b2\x0b.InstanceIDR\ninstanceId\x12\x0e\n\x02ok\x18\x04\
    \x20\x01(\x08R\x02ok\x12\"\n\x06ballot\x18\x05\x20\x01(\x0b2\n.BallotNum\
    R\x06ballot\x12%\n\x08instance\x18\x06\x20\x01(\x0b2\t.InstanceR\x08inst\
    ance\"\xc3\x01\n\x0cPreAcceptReq\x12\x1b\n\tleader_id\x18\x01\x20\x01(\
    \x03R\x08leaderId\x12\x1d\n\nreplica_id\x18\x02\x20\x01(\x03R\treplicaId\
    \x12,\n\x0binstance_id\x18\x03\x20\x01(\x0b2\x0b.InstanceIDR\ninstanceId\
    \x12%\n\x08instance\x18\x04\x20\x01(\x0b2\t.InstanceR\x08instance\x12\"\
    \n\x06ballot\x18\x05\x20\x01(\x0b2\n.BallotNumR\x06ballot\"\xbe\x01\n\
    \x0ePreAcceptReply\x12\x1d\n\nreplica_id\x18\x01\x20\x01(\x03R\treplicaI\
    d\x12%\n\x08instance\x18\x02\x20\x01(\x0b2\t.InstanceR\x08instance\x12\
    \x0e\n\x02ok\x18\x03\x20\x01(\x08R\x02ok\x12\"\n\x06ballot\x18\x04\x20\
    \x01(\x0b2\n.BallotNumR\x06ballot\x122\n\x0ecommitted_deps\x18\x05\x20\
    \x03(\x0b2\x0b.InstanceIDR\rcommittedDeps\"\xa8\x01\n\tAcceptReq\x12\x1b\
    \n\tleader_id\x18\x01\x20\x01(\x03R\x08leaderId\x12\x1d\n\nreplica_id\
    \x18\x02\x20\x01(\x03R\treplicaId\x12%\n\x08instance\x18\x03\x20\x01(\
    \x0b2\t.InstanceR\x08instance\x12\"\n\x06ballot\x18\x04\x20\x01(\x0b2\n.\
    BallotNumR\x06ballot\x12\x14\n\x05count\x18\x05\x20\x01(\x05R\x05count\"\
    \x8e\x01\n\x0bAcceptReply\x12\x1d\n\nreplica_id\x18\x01\x20\x01(\x03R\tr\
    eplicaId\x12,\n\x0binstance_id\x18\x02\x20\x01(\x0b2\x0b.InstanceIDR\nin\
    stanceId\x12\x0e\n\x02ok\x18\x03\x20\x01(\x08R\x02ok\x12\"\n\x06ballot\
    \x18\x04\x20\x01(\x0b2\n.BallotNumR\x06ballot\"n\n\tCommitReq\x12\x1b\n\
    \tleader_id\x18\x01\x20\x01(\x03R\x08leaderId\x12\x1d\n\nreplica_id\x18\
    \x02\x20\x01(\x03R\treplicaId\x12%\n\x08instance\x18\x03\x20\x01(\x0b2\t\
    .InstanceR\x08instance\"\xc0\x01\n\x0bCommitShort\x12\x1b\n\tleader_id\
    \x18\x01\x20\x01(\x03R\x08leaderId\x12\x1d\n\nreplica_id\x18\x02\x20\x01\
    (\x03R\treplicaId\x12,\n\x0binstance_id\x18\x03\x20\x01(\x0b2\x0b.Instan\
    ceIDR\ninstanceId\x12\x14\n\x05count\x18\x04\x20\x01(\x05R\x05count\x12\
    \x10\n\x03seq\x18\x05\x20\x01(\x05R\x03seq\x12\x1f\n\x04deps\x18\x06\x20\
    \x03(\x0b2\x0b.InstanceIDR\x04deps\"\xc6\x01\n\x0fTryPreAcceptReq\x12\
    \x1b\n\tleader_id\x18\x01\x20\x01(\x03R\x08leaderId\x12\x1d\n\nreplica_i\
    d\x18\x02\x20\x01(\x03R\treplicaId\x12,\n\x0binstance_id\x18\x03\x20\x01\
    (\x0b2\x0b.InstanceIDR\ninstanceId\x12\"\n\x06ballot\x18\x04\x20\x01(\
    \x0b2\n.BallotNumR\x06ballot\x12%\n\x08instance\x18\x05\x20\x01(\x0b2\t.\
    InstanceR\x08instance\"\xd9\x02\n\x11TryPreAcceptReply\x12\x1f\n\x0bacce\
    ptor_id\x18\x01\x20\x01(\x03R\nacceptorId\x12\x1d\n\nreplica_id\x18\x02\
    \x20\x01(\x03R\treplicaId\x12,\n\x0binstance_id\x18\x03\x20\x01(\x0b2\
    \x0b.InstanceIDR\ninstanceId\x12\x0e\n\x02ok\x18\x04\x20\x01(\x08R\x02ok\
    \x12\"\n\x06ballot\x18\x05\x20\x01(\x0b2\n.BallotNumR\x06ballot\x12)\n\
    \x10conflict_replica\x18\x06\x20\x01(\x03R\x0fconflictReplica\x12=\n\x14\
    conflict_instance_id\x18\x07\x20\x01(\x0b2\x0b.InstanceIDR\x12conflictIn\
    stanceId\x128\n\x0fconflict_status\x18\x08\x20\x01(\x0e2\x0f.InstanceSta\
    tusR\x0econflictStatus*S\n\x0bRequestType\x12\x0b\n\x07Prepare\x10\0\x12\
    \x10\n\x0cTryPreAccept\x10\x01\x12\r\n\tPreAccept\x10\x02\x12\n\n\x06Acc\
    ept\x10\x03\x12\n\n\x06Commit\x10\x04*-\n\x0bMessageType\x12\x0f\n\x0bTy\
    peRequest\x10\0\x12\r\n\tTypeReply\x10\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
